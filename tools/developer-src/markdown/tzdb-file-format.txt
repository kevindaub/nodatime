tzdb binary file format

This document describes the Noda Time-specific binary file format that
`ZoneInfoCompiler` produces. `ZoneInfoCompiler` takes the tzdb text files and
some CLDR data as input; it produces one of two different output formats:

   1. a .NET resource file containing a number of different resources
      (including, for example, one for each time zone), serialised as either
      an XML (`.resx`) or compiled (`.resources`) file. This is the only
      format accepted by Noda Time 1.0.x.

   2. a binary file format (the "NodaZoneData" format) that does not depend
      upon a .NET resource file acting as a container. This is the default
      format in Noda Time 1.1 and later, and is the only format supported by
      the Portable Class Library versions of Noda Time.

The formats have some similarities, but can be treated independently. In
particular, the resource format supported by Noda Time 1.0.x is effectively
frozen, while the NodaZoneData format will evolve as more data is required.

# Version compatibility

Most users will just use the version of the database embedded in the Noda
Time assembly (which is typically produced with the same version of
`ZoneInfoCompiler` as the Noda Time assembly itself), and so do not need to
worry about these details, but as we provide the ability to use a custom
compiled tzdb database, we document here the compatibility rules between
the output produced by different versions of `ZoneInfoCompiler` and the Noda
Time assembly.

In general, these are probably as you would expect: any version of Noda Time
must be able to read a compiled tzdb database consumed by an earlier version
of Noda Time with the same major version number; the reverse, however, is
not true.

For example, Noda Time 1.1.x should be able to read the compiled output used
by Noda Time 1.0.x and 1.1.x, but would not necessarily be able to read the
output used by version 1.2.x. Noda Time 2.x does not necessarily need to be
able to read anything consumed by Noda Time 1.x.

(The same is true for the PCL version of Noda Time, though it is considered
a separate development line for the purposes of compatibility, and so does
not need to support the same features as the earlier [non-PCL] versions.)

Note that even though Noda Time must _read_ earlier versions of the compiled
database, it does not necessarily need to provide the same level of
functionality when doing so as it might when reading a current version. In
particular, only calls to methods supported by that earlier version of Noda
Time are guaranteed to work; any calls to methods introduced in a later
version may require a database compiled by at least that version.

The former is true because semantic versioning requires that we be able to
drop a later version of the Noda Time assembly into a running environment
without recompiling (or without replacing the compiled tzdb database, which
might e.g. be embedded in the main executable); the latter statement is true
because it is unreasonable to expect that new functionality should work
without the new data it may require.

As a consequence, it is reasonable to act as if any functionality introduced
in a given version of Noda Time comes with an implicit caveat that it
requires a database compiled against at least that version to work.

# NodaZoneData format

TODO

# Resource file format

A compiled database in the .NET resource file format native to Noda Time
1.0.x is a .NET resource file containing many resources: one per time zone,
and four additional meta-information resources.

The four meta-information resources, and their resource keys, are:

   * `--meta-VersionId`, a `String` resource containing the tzdb version ID
     (e.g. "2012i")
   * `--meta-IdMap`, a `byte[]` resource containing a serialised
     `dictionary` (see below for the definition of these types), mapping all
     known time zone IDs (aliases and non-aliases) to a non-alias time zone
     ID
   * `--meta-WindowsToPosix`, a `byte[]` resource containing a serialised
     `dictionary`, mapping Windows time zone names to the corresponding tzdb
     time zone ID
   * `--meta-WindowsToPosixVersion`, a `String` resource containing the
     revision number of the Windows mapping data (e.g. "7825")

Each non-alias time zone is represented by a `byte[]` resource containing a
serialised `timezone`. The name of the resource is derived from the time zone
ID, with (theoretically) some substitutions for invalid characters.  (The
substitutions are not documented here, since they do not actually appear to be
used in practice; for example, the name of the Europe/London resource is simply
"Europe/London", and the same appears to be true for all other time zones as of
the 2012i tzdb). 

All of these resources may (theoretically) contain extra appended data not
mentioned below; readers do not confirm that the end of the resource was
reached when all the data they know how to read has been consumed.

## Serialisation primitives

The resource file format uses the following serialisation primitives:

   * `fixed16`, `fixed32`, and `fixed64`, general 16-bit, 32-bit, and 64-bit
     signed integers
   * `count`, a non-negative (typically small) `int32` value
   * `offset`, an `int32` value representing a millisecond offset from UTC
   * `string`, a UTF-8 encoded text string
   * `dictionary`, a dictionary with string keys and values
   * `timezone`, a serialised time zone (with several variants)

Of these, only `dictionary` and `timezone` are used directly; the others are
used as part of the definitions of these types, below.

### Fixed16, Fixed32, Fixed64

`fixed16`, `fixed32`, and `fixed64` are simply serialised as 2-, 4-, or
8-byte twos-complement values of the appropriate length, in MSB-first order.
For example, `0x1234` would be serialised as the bytes `[0x12 0x34]` using
the `fixed16` serialisation, while -1 would be serialised as `[0xff 0xff]`.

### Count

A `count` encodes a non-negative (typically small) `int32` value; it is
serialised as a variable number of bytes according to the following
scheme:

   * Values `0x00`..`0x8e` are serialised as a single byte; values to `0x0e`
     are serialised as `0xf0`..`0xfe`, while `0x0f`..`0x8e` is serialised as
     `0x00`..`0x7f`
   * `0x8f`..`0x408e` is serialised as two bytes, by subtracting `0x8f` and
     then encoding the resulting (`0`&ndash;`0x3fff`) value using the byte
     `0x80`..`0xbf` for the MSB, followed by the LSB
   * `0x408f`..`0x20408e` is serialised as three bytes, by subtracting
     `0x408f` and then encoding the resulting (`0`&ndash;`0x1fffff`) value
     as the byte `0xc0`..`0xdf` for the MSB, followed by the next two bytes
     in MSB-first order (i.e. as a `fixed16`)
   * `0x20408f`..`0x1020408e` is serialised as four bytes, by subtracting
     `0x20408f` (giving `0`&ndash;`0x0fffffff`), adding `0xe0000000`,
     and then encoding the resulting (`0xe0000000`&ndash;`0xefffffff`) value
     as a `fixed32`
   * Larger values are serialised as five bytes, as the leader `0xff`
     followed by the value as a `fixed32`

### Offset

An `offset` encodes an `int32` value representing an offset in milliseconds
from UTC. While the encoding below can in theory represent any `int32`
value, it is in practice used for values in the range (-24 hours, +24
hours), and typically for 'round' values.

An `offset` is serialised as a variable-length field as follows:

   * Offsets that are a multiple of 30 minutes are serialised as the single
     byte `0x10`..`0x6e`, with a bias such that `0x10` represents an offset
     of -23:30, `0x11` represents -23:00, `0x3f` represents a zero offset,
     and `0x6e` represents the offset +23:30.
   * Offsets that are a whole number of seconds are serialised as three
     bytes, the first of which is in the range `0x82`..`0x85`, by adding
     `0x83ffff` to the value, and writing three bytes in MSB-first order, so
     that `[0x82 0xae 0x80]` represents -23:59:59, `[0x84 0x00 0x00]`
     represents +00:00:01, and `[0x85 0x51 0x7e]` represents +23:59:59.
   * Any other offset is serialised as the leader `0xfd` followed by the number
     of milliseconds as a `fixed32`

(The serialisation method used actually defines an encoding for
'out-of-range' offsets, but these cannot occur in practice, as the
underlying C# data type restricts the range of the offset to that described
above.)

### String

A `string` is serialised as a `count` of the number of UTF-8 bytes in the
string followed by those bytes.

### Dictionary

A `dictionary` is serialised as a `count` number of entries in the
dictionary, followed by that number of pairs of `string` key and `string`
value.

### Timezone

A `timezone` encodes a time zone, represented in one of a few different
forms. The serialised format may be any of the following:

   * `0x00` followed by another `timezone`, indicating that the following time
     zone (in practice, always one of type `0x04`) should have information
     about zone transitions cached if possible
   * `0x01` followed by a `daylightsavingstimezone`, representing a time
     zone with a 'standard' and 'dst' offset and simple recurrence rules for
     each transition
   * `0x02` followed by an `offset`, representing a time zone with a fixed
     offset (and no DST); this is used natively when encoding time zones
     with no DST (such as "Etc/UTC") and as part of the composite
     "pre-calculated" time zone
   * `0x03`, representing 'no time zone' (only used when encoding an absent
     tailzone for a pre-calculated zone)
   * `0x04` followed by a `precalculatedtimezone`, representing a zone that
     expands all known transitions explicitly, with an optional 'tail zone'
     representing a final DST-using stable state

#### daylightsavingstimezone

A `daylightsavingstimezone` is serialised as an `offset` containing the
standard offset followed by the DST `zonerecurrence` and the standard time
(non-DST) `zonerecurrence`.  The DST recurrence contains an offset that is
the additional delta from the standard offset for daylight savings time
(usually positive, but sometimes zero); the standard time recurrence is
guaranteed to have a zero offset.

##### zonerecurrence

A `zonerecurrence` is serialised as the `string` name of the recurrence
(e.g. "PST"), the `offset` containing the offset of this recurrence, a
description of when the recurrence occurs (the 'year offset'), followed by a
`count` of the year the recurrence starts (zero if it starts at the
beginning of time) and a `count` of the year that the recurrence ends.

(Note that 1.0 versions of NodaTime serialised the 'beginning of time' as
`int32.MinValue` instead of zero. The two should be treated equally.)

The description of the recurrence is:

   * a `count` indicating whether transitions are relative to UTC (0), the
     'wall' (daylight savings) offset (1), or the standard offset (2)
   * 

#### precalculatedtimezone

tailzone is always either of type `0x03` (no time zone) or `0x01`
(`daylightsavingstimezone`)

